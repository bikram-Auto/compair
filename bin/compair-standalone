#!/usr/bin/env node
(()=>{"use strict";var e={317:e=>{e.exports=require("child_process")},896:e=>{e.exports=require("fs")},928:e=>{e.exports=require("path")},542:function(e,o,n){var t=this&&this.__createBinding||(Object.create?function(e,o,n,t){if(t===undefined)t=n;var s=Object.getOwnPropertyDescriptor(o,n);if(!s||("get"in s?!o.__esModule:s.writable||s.configurable)){s={enumerable:true,get:function(){return o[n]}}}Object.defineProperty(e,t,s)}:function(e,o,n,t){if(t===undefined)t=n;e[t]=o[n]});var s=this&&this.__setModuleDefault||(Object.create?function(e,o){Object.defineProperty(e,"default",{enumerable:true,value:o})}:function(e,o){e["default"]=o});var r=this&&this.__importStar||function(){var ownKeys=function(e){ownKeys=Object.getOwnPropertyNames||function(e){var o=[];for(var n in e)if(Object.prototype.hasOwnProperty.call(e,n))o[o.length]=n;return o};return ownKeys(e)};return function(e){if(e&&e.__esModule)return e;var o={};if(e!=null)for(var n=ownKeys(e),r=0;r<n.length;r++)if(n[r]!=="default")t(o,e,n[r]);s(o,e);return o}}();Object.defineProperty(o,"__esModule",{value:true});const c=r(n(896));const i=r(n(928));const l=n(317);function deleteFolderContentsRecursive(e){const o=[];try{const n=c.readdirSync(e);for(const t of n){const n=i.join(e,t);try{const e=c.statSync(n);if(e.isDirectory()){const e=deleteFolderContentsRecursive(n);o.push(...e);c.rmdirSync(n)}else{c.unlinkSync(n);o.push(t)}}catch(e){console.warn(`Warning: Could not delete ${t}`)}}}catch(o){console.warn(`Warning: Could not read directory ${e}`)}return o}function getAllFilesRecursive(e,o="",n=new Set,t=100,s=0){const r=[];if(s>t){return r}if(n.has(e)){return r}n.add(e);try{const l=c.readdirSync(e);for(const u of l){const l=i.join(e,u);const a=o?i.join(o,u):u;try{const e=c.lstatSync(l);if(e.isFile()){r.push(a)}else if(e.isDirectory()&&!e.isSymbolicLink()){try{const e=getAllFilesRecursive(l,a,new Set(n),t,s+1);r.push(...e)}catch(e){continue}}}catch(e){continue}}}catch(e){}return r}async function compareFolders(e,o,n=true,t=false){const s={folderA:e,folderB:o,uniqueInA:[],common:[],uniqueInB:[],copiedFiles:[],deletedFiles:[],errors:[]};try{if(!c.existsSync(e)){s.errors.push(`Folder A does not exist: ${e}`);return s}if(!c.existsSync(o)){s.errors.push(`Folder B does not exist: ${o}`);return s}console.log(`Scanning source folder (${e})...`);const r=getAllFilesRecursive(e);console.log(`Found ${r.length} files in source folder`);console.log(`Scanning destination folder (${o})...`);let l=getAllFilesRecursive(o);console.log(`Found ${l.length} files in destination folder`);const u=new Set(r);const a=new Set(l);if(t&&l.length>0){const e=r.length!==l.length||!r.every((e=>a.has(e)));if(e){console.log(`Sync mode: Deleting all contents from ${o}...\n`);const e=deleteFolderContentsRecursive(o);s.deletedFiles=e;l=[];e.forEach((e=>console.log(` Deleted: ${e}`)))}}for(const e of r){if(a.has(e)){s.common.push(e)}else{s.uniqueInA.push(e)}}for(const e of l){if(!u.has(e)){s.uniqueInB.push(e)}}if(n){const n=t?r:s.uniqueInA;if(n.length>0){for(const t of n){try{const n=i.join(e,t);const r=i.join(o,t);const l=i.dirname(r);if(!c.existsSync(l)){c.mkdirSync(l,{recursive:true})}c.copyFileSync(n,r);s.copiedFiles.push(t);console.log(`âœ“ Copied: ${t}`)}catch(e){const o=e instanceof Error?e.message:String(e);s.errors.push(`Failed to copy ${t}: ${o}`)}}}}}catch(e){const o=e instanceof Error?e.message:String(e);s.errors.push(`Comparison error: ${o}`)}return s}function printResults(e){console.log("\n"+"=".repeat(60));console.log("FOLDER COMPARISON REPORT");console.log("=".repeat(60));console.log(`Folder A (Source): ${e.folderA}`);console.log(`Folder B (Destination): ${e.folderB}`);console.log("=".repeat(60));if(e.uniqueInA.length>0){console.log(`\n Unique in Folder A (${e.uniqueInA.length}):`);e.uniqueInA.forEach((e=>console.log(`  - ${e}`)))}if(e.common.length>0){console.log(`\n Common files (${e.common.length}):`);if(e.common.length<5)e.common.forEach((e=>console.log(`  - ${e}`)))}if(e.uniqueInB.length>0){console.log(`\n Unique in Folder B (${e.uniqueInB.length}):`);e.uniqueInB.forEach((e=>console.log(`  - ${e}`)))}if(e.deletedFiles.length>0){console.log(`\n Deleted files (${e.deletedFiles.length}):`);e.deletedFiles.forEach((e=>console.log(`  - ${e}`)))}if(e.copiedFiles.length>0){console.log(`\n Successfully copied files (${e.copiedFiles.length}):`);e.copiedFiles.forEach((e=>console.log(`  - ${e}`)))}if(e.errors.length>0){console.log(`\n Errors (${e.errors.length}):`);e.errors.forEach((e=>console.log(`  - ${e}`)))}console.log("\n"+"=".repeat(60)+"\n")}function estimateFileCount(e,o=2,n=0){if(n>o||!c.existsSync(e)){return 0}let t=0;try{const s=c.readdirSync(e);for(const r of s){const s=i.join(e,r);try{const e=c.lstatSync(s);if(e.isFile()){t++}else if(e.isDirectory()&&!e.isSymbolicLink()&&n<o){t+=estimateFileCount(s,o,n+1)}}catch(e){}}}catch(e){}return t}function calculateRequiredStackSize(e){const o=1024;const n=o+Math.ceil(e/500);const t=1024;const s=8192;const r=Math.max(t,Math.min(s,n));return r}async function ensureSufficientStackSize(e,o){console.log("Analyzing folder structure...");const n=estimateFileCount(e,2);const t=estimateFileCount(o,2);const s=n+t;const r=calculateRequiredStackSize(s);if(s<1e4){return false}console.log(`Detected approximately ${s} files (estimated).`);console.log(`Required stack size: ${r} MB`);if(process.env.COMPAIR_STACK_SIZE_ADJUSTED==="true"){console.log("Already running with optimized stack size.\n");return false}console.log("Relaunching with optimized stack size...\n");return new Promise((e=>{const o={...process.env,COMPAIR_STACK_SIZE_ADJUSTED:"true"};const n=`--stack-size=${Math.max(1024,r)}`;const t=(0,l.spawn)(process.execPath,[n,process.argv[1],...process.argv.slice(2)],{env:o,stdio:"inherit"});t.on("exit",(e=>{process.exit(e||0)}));e(true)}))}async function main(){const e=process.argv.slice(2);if(e.length<2){console.log("Usage: npx ts-node index.ts <folderA> <folderB> [options]");console.log("\nOptions:");console.log("  --no-copy    Only compare, don't copy files");console.log("  --sync       Delete all from B and copy all from A (full sync)");console.log("\nExample: npx ts-node index.ts ./source ./destination");console.log("Example: npx ts-node index.ts ./source ./destination --sync\n");process.exit(1)}const o=e[0];const n=e[1];const t=await ensureSufficientStackSize(o,n);if(t){return}const s=!e.includes("--no-copy");const r=e.includes("--sync");if(r){console.log(`SYNC MODE: Folder B will be replaced with exact copy of Folder A\n`)}console.log(`Comparing folders...\n`);const c=await compareFolders(o,n,s,r);printResults(c)}main().catch((e=>{console.error("Fatal error:",e);process.exit(1)}))}};var o={};function __nccwpck_require__(n){var t=o[n];if(t!==undefined){return t.exports}var s=o[n]={exports:{}};var r=true;try{e[n].call(s.exports,s,s.exports,__nccwpck_require__);r=false}finally{if(r)delete o[n]}return s.exports}if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";var n=__nccwpck_require__(542);module.exports=n})();